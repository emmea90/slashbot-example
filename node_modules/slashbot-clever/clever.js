var Cleverbot = require('cleverbot-node')
var cleverbot = new Cleverbot()
var debug = require('debug')('slashbot-clever')

/**
 * clever listener
 * this is a function that will be called whenever a message is sent to a channel our slashbot is in.
 *
 * A listener will be called with the following scope:
 * this.slack - an instance of `node-slack-client`.
 * this.channel - an instance of a channel object. (the channel the message was sent to)
 * this.user - an instance of a user object. (the user that sent the message)
 * this.name - our bot name.
 * this.respond - a method to send a more customized response back to slack. Check out the slashbot docs for more on the respond method.
 *
 * @param {string} message - the message received
 * @param {callback} [callback] - a callback to call with a response.
 */
var clever = function(message,callback) {
  var botName = this.name
  var pattern = new RegExp('^(.*)@?' + botName + ':?(.*)$','i')
  var matches = message.match(pattern)
  // skip if we didn't mention the bot
  if(!matches || !matches.length) return

  // assemble the string we sent, minus the bot name.
  var string = matches.slice(1).join(' ').trim()

  // send it to cleverbot and send the response back to the user.
  Cleverbot.prepare(function(){
    cleverbot.write(string, function(response){
      debug('got response from cleverbot: %s',JSON.stringify(response))
      var answer = charsDecode(response.message)
      callback(null,answer)
    });
  });
  /**
   * If we return false, this will stop other listeners from being executed after this one.
   * In our case, we want to allow listening to continue, so we'll return true.
   * Skipping the return statement (or returning undefined) would have the same effect.
   */
  return true
}

function htmlDecode(str) {
  str.replace("&Aacute;","Á")
  str.replace("&aacute;","á")
  str.replace("&Agrave;","À")
  str.replace("&Acirc;","Â")
  str.replace("&agrave;","à")
  str.replace("&Acirc;","Â")
  str.replace("&acirc;","â")
  str.replace("&Auml;","Ä")
  str.replace("&auml;","ä")
  str.replace("&Atilde;","Ã")
  str.replace("&atilde;","ã")
  str.replace("&Aring;","Å")
  str.replace("&aring;","å")
  str.replace("&Aelig;","Æ")
  str.replace("&aelig;","æ")
  str.replace("&Ccedil;","Ç")
  str.replace("&ccedil;","ç")
  str.replace("&Eth;","Ð")
  str.replace("&eth;","ð")
  str.replace("&Eacute;","É")
  str.replace("&eacute;","é")
  str.replace("&Egrave;","È")
  str.replace("&egrave;","è")
  str.replace("&Ecirc;","Ê")
  str.replace("&ecirc;","ê")
  str.replace("&Euml;","Ë")
  str.replace("&euml;","ë")
  str.replace("&Iacute;","Í")
  str.replace("&iacute;","í")
  str.replace("&Igrave;","Ì")
  str.replace("&igrave;","ì")
  str.replace("&Icirc;&icirc;","Îî")
  str.replace("&Iuml;","Ï")
  str.replace("&iuml;","ï")
  str.replace("&Ntilde;","Ñ")
  str.replace("&ntilde;","ñ")
  str.replace("&Oacute;","Ó")
  str.replace("&oacute;","ó")
  str.replace("&Ograve;","Ò")
  str.replace("&ograve;","ò")
  str.replace("&Ocirc;","Ô")
  str.replace("&ocirc;","ô")
  str.replace("&Ouml;","Ö")
  str.replace("&ouml;","ö")
  str.replace("&Otilde;","Õ")
  str.replace("&otilde;","õ")
  str.replace("&Oslash;","Ø")
  str.replace("&oslash;","ø")
  str.replace("&szlig;","ß")
  str.replace("&Thorn;","Þ")
  str.replace("&thorn;","þ")
  str.replace("&Uacute;","Ú")
  str.replace("&uacute;","ú")
  str.replace("&Ugrave;","Ù")
  str.replace("&ugrave;","ù")
  str.replace("&Ucirc;","Û")
  str.replace("&ucirc;","û")
  str.replace("&Uuml;","Ü")
  str.replace("&uuml;","ü")
  str.replace("&Yacute;","Ý")
  str.replace("&yacute;","ý")
  str.replace("&yuml;","ÿ")
  str.replace("&copy;","©")
  str.replace("&reg;","®")
  str.replace("&trade;","™")
  str.replace("&amp;","&")
  str.replace("&lt;","<")
  str.replace("&gt;",">")
  str.replace("&euro;","€")
  str.replace("&cent;","¢ ")
  str.replace("&pound;","£ ")
  str.replace("","")
  str.replace("&quot;","\"")
  str.replace("&lsquo;","‘ ")
  str.replace("&rsquo;","’ ")
  str.replace("&ldquo;","“ ")
  str.replace("&rdquo;","” ")
  str.replace("&laquo;","« ")
  str.replace("&raquo;","» ")
  str.replace("","")
  str.replace("&mdash;","— ")
  str.replace("&ndash;","– ")
  str.replace("&deg;","° ")
  str.replace("&plusmn;","± ")
  str.replace("&frac14;","¼ ")
  str.replace("&frac12;","½ ")
  str.replace("&frac34;","¾ ")
  str.replace("&times;","× ")
  str.replace("&divide;","÷ ")
  str.replace("&alpha;","α ")
  str.replace("&beta;","β ")
  str.replace("&infin;","∞ ")
  return str;
}

/**
 * match - we can specify a match property on the exported function to limit matches to this object.
 * In this case however, we want to dynamically generate a match regex, so we're doing it in the listener
 * instead of on the function.
 *
 * If we wanted to specify something more simple, we can do it here:
 *
 * clever.match = <regex>
 */

/**
 * export our listener function
 */
module.exports = clever
